手動テスト
手動テスト（manual test）では、QA チームのメンバーや開発者が手動で個々のテストを書いてエラーを特定します。
ここまで、私たちは手動テストのみを作成してきました。
先ほどの例では、equalAssertion(a,b,callback) 関数を使ってデータを渡し、結果を確認しました。

手動テストには長所と短所があります。

手動テストの長所
- ほとんどのケースでは手動テストは必須であり、通常、テストケースの最初のセットになります。
- 少量のテストケースをテストしたい場合、手動テストの方が効率が良いです。
- エッジケースをチェックするのにも便利です。エッジケースとは、問題のコードのパラメータが限界に達している場合や、プログラムの境界をテストするケースのことです。論理エラーはエッジケースで多く発生します。
- 手動テストは事前に定義されたパラメータや基準に限定されない柔軟性を持っているため、エラーの原因を特定したり、原因を理解するのが難しい場合に便利です。この場合、多くのケースでは経験則に基づいたテストになるため、その場で書かれます。
- テストの中には、自動化できないものもありますし、自動化するには多くの作業と労力が必要になるので、手動テストが唯一の選択肢となる場合もあります。

手動テストの短所
- 非常に時間がかかります。
- 無秩序になりやすいです。テストしたいコードとテストコードが一緒になってしまいます。
- モジュール化されていません。つまり、簡単に再利用することはできません。
- 比較的テストケースによるエラーが発生しやすいです。開発者によるテスト作成ミスやロジックのミスによって間違ったテストケースが発生することがあります。手動テストは信頼性とセキュリティのために使用されますが、コードが拡張されることによって引き起こされる副作用を利用して、状態を変更したかどうかをチェックすることもあります。
- 手動テストでは、何百万ものエントリや何テラバイトもの入力データを用いて、正確なパフォーマンスデータを得るようなテストには使用できません。

自動テスト
自動テスト（automatic test）では、QA チームのメンバーや開発者がスクリプトを書き、
専用のソフトウェアを使用してエラーの識別を自動化します。
多くの場合、QA テスターの専門チームによって行われ、実際のコードの実装とは別に行われます。

例を使って、自動テストの利点を探ってみます。

n までの素数を取り出すためにエラトステネスのふるいを使った関数から始めましょう。
このアルゴリズムを検証する自動テストを作成します。
このテストは、リスト内のすべての項目が素数であるかどうか、
すべてが重複していないか、すべてが n 以下であるかどうか、
そして k 個の素数が含まれているかどうかのチェックを行います。

では、100 までの素数をテストしてみましょう。
100 未満の素数は全部で 25 個あるはずです。

'''

import math

def assertionTest(a, callback):
    result = callback(a)
    print(f"Checking against {str(a)}, is it valid?...{result}")
    assert result
    return True

def sieveOfPrimes(n):
    cache = [True] * n
    for currentPrime in range(2, math.ceil(math.sqrt(n))):
        i = 2
        ip = i * currentPrime
        while ip < n:
            cache[ip] = False
            i += 1
            ip = i * currentPrime

    primeNumbers = []
    for index, predicate in enumerate(cache):
        if predicate: primeNumbers.append(index)

    return primeNumbers[2:]

# kとnを受け取り、リストAを取り込み、A内の全ての要素が重複しておらず、かつn以下の素数であり、合計でk個存在するかチェックする関数を返します。
# 返されるデータは、クロージャー関数です。
def primeCheck(k, n):
    def isPrime(num):
        if num > 1:
            for i in range(2, math.floor(math.sqrt(num))):
                if (num % i) == 0: return False
            return True
        return False

    def script(aList):
        # set() はリストを受け取り、重複していない要素のみを返します。
        if not len(set(aList)) == len(aList): return False
        if not len(aList) == k: return False
        for i in range(len(aList)):
            if aList[i] > n or not isPrime(aList[i]) : return False
        return True

    return script

if __name__ == '__main__':
    assertionTest([2,3,5,7,11,13],primeCheck(6, 15))
    assertionTest(sieveOfPrimes(15),primeCheck(6, 15))
    assertionTest(sieveOfPrimes(100),primeCheck(25, 100))
    assertionTest(sieveOfPrimes(10000),primeCheck(1229, 10000))

    # assertionTest([2,3,5,7,11,13,15],primeCheck(6, 15)) # Error
    # assertionTest([2,3,5,7,11,12],primeCheck(6, 15)) # Error
    # assertionTest([2,3,5,7,11,19],primeCheck(6, 15)) # Error

'''

私たちが直接データを書いたり、テストを考えたりせずとも、
この自動プログラムはエラトステネスのふるいの関数の整合性を保証してくれます。
さらにこの自動プログラムを使って、
10000 のようなより大きな素数をチェックすることができます。


関数が正しいことを保証するこのような自動テストを書くには、
特定の領域の知識や情報が必要になります。
今回のケースでは、数値 n までに含まれる素数の個数kになります。
k がわからずともテストを行うことはできますが、
整合性を保証することは難しいでしょう。


今回、私たちは公開されている素数のデータベースを使って、
n に対する k の情報を得ることにしました。
現場では、自動テストケースを作成して解法に自信を持っていたとしても、
その解法の整合性を保証できないというケースがあります。
これは情報が限定されている場合や、
解答が不可能である場合、
証明するのが非常に困難である場合、
エッジケースがわからない場合が問題の原因となります。



ランダムなデータを生成するコードを書いて、
生成されたものをチェックするテストを書くと作業がより簡単になるようなケースもあります。
例えば、偽の電子メール、年齢、日付を生成して、ユーザーオブジェクトとその動作をテストするようなケースが挙げられます。
この場合、テストがチェックしなければならないのは入出力関係になります。

自動テストの長所
- プログラムを自動的にテストし、データを生成することで、膨大な量のデータをテストし、時間計算量や空間計算量をテストすることができます。
- テストケースと入力を手動ではなく、アルゴリズム的に生成できます。
- アルゴリズムの整合性が証明できたり、それを保証するデータがあれば、自動テストによって全ての作業を行うことができます。
- 動的ではない手動テストとは異なり、数行のコードでテスト基準のロジックを拡張することができます。
- テストを自動化するために、最新のツールやA.Iが利用できます。

自動テストの短所
- 単発のテストは、手動テストを使用した方がはるかに効率的かつ迅速に行われます。テストケースが少なくて済む場合、特別なソフトウェアを使用したり、スクリプトを書くことは現実的ではありません。
- アルゴリズムテストを書くためには、問題に関する知識が必要になります。
- テストパラメータが事前に設定されているため、探索的テスト（exploratory test）ができません。エッジケース等の特定のデータセットをテストすることができません。
- 特定のテストは自動化することができません。また、リソースの消費が激しくなってしまう場合があります。

                                  自動テスト	                          手動テスト
財政的コスト                       ほとんどのプロジェクトでは安価	         シンプルなものを除いて高価
人的コスト                         高（通常、QAチームによって行われる）	     低（通常、開発メンバーによって行われる）
時間的コスト                       低	                                   高
再利用性                           高	                                   低
エラーの可能性                     低	                                   高
結果のプログラムへの利用	        Yes	                                    No
探索的テストの可否	                No	                                   Yes
エッジケーステストの実装難易度	     低	                                    高



QA チームのメンバーや開発者が手動で個々のテストを書いてエラーを特定することを手動テストといい、
スクリプトを書き、専用のソフトウェアを使用してエラーの識別を自動化することを自動テストという。

手動テストを避けた方が良い状況として 何百万ものエントリや何テラバイトものデータをテストしたいとき があげられる

手動テストの長所は局所的な箇所を調べることができる

自動テストを避けた方が良い状況は、エラーの原因を特定したり、原因を理解するのが難しいとき などがあげられる。

自動テストの短所はエッジケースを局所的に調べることができない

自動テストの長所は簡単に再利用することができる

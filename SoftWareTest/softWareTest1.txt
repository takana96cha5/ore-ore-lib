ソフトウェアテスト
プログラムが全く実行されなかったり、出力値が正しくなかったり、断続的にしか正しい値を出力しないことはよく目にするでしょう。
特に最初の完成物から意図した結果を得られることはほとんどありません。


出力値の正誤以外に他の要件を満たす必要があるケースも存在します。
例えば、作成中のソフトウェアが 3D アニメーションのフレームを特定の時間内にレンダリングする必要があったり、
アジャイル環境でチーム開発を行う際には、各イテレーション（iteration）でプログラムが適切に動作するかどうかをチェックする必要があります。

この節では、関数やコンポーネント、プログラム全体のテストの仕方を学習します。

ソフトウェアの問題点に対しては「失敗」、「エラー」、「障害」、「欠陥」、「バグ」などの用語が使われます。
学術的な文献やプロフェッショナルな現場では、
多くの用語が互換性を持って使われていたり、
説明する人によって異なる定義を持つこともあります。

Recursion のコンテンツでは、一貫性を持たせるため、以下の定義に従います。

用語	定義
エラー	ソフトウェアプロジェクトのコード中のミス。(開発者が気づいている場合と気づいていない場合があります。)
バグ	開発者が気づいたエラー。

ソフトウェアの構造
私たちは人間なので、想定外の問題を避けることはできません。
したがって、設計した複雑なシステムには必ず何らかのエラーがあります。
しかし、プロジェクトの要件を満たしつつ、エラーを特定、修正、防止を可能にする体系的な戦略があり、
これらの戦略には次のようなものがあります。

- ソフトウェアのテスト
- 例外処理
- ソフトウェアのデバッグ
- 防御的プログラミング（defensive programming）
- 成功事例の活用

これらの戦略はセキュリティ対策として適用されることが多く、
プログラムは予期せぬものも含めて多くのケースに対応することができます。
また、これらはソフトウェアの異なる階層に適用されます。
ソフトウェアが大きく複雑になればなるほど、
良質なコードを維持するために異なる階層ごとに戦略が適用されるのです。

では、ソフトウェアを生命体の構造に置き換えてみましょう。

生命体（organism）
    器官（organ）
        組織（tissue）
            細胞（cell）
                分子（molecule）
                    原子（atom）


階層	生命	    ソフトウェア
高      生命体	    ソフトウェア製品全体
中	    器官/組織	モジュール、クラス、オブジェクト、メソッド、関数
低	    細胞/分子	数行のコード
基礎	原子	    単一のコード


どのようなプロジェクトであっても、コードのどの部分にセキュリティテストと例外処理が必要か把握するための費用対効果分析が必要になります。
例えば、数百万ドルの価値がある大企業のプロジェクトでは、ソフトウェアの高階層と低階層の両方で大規模なテストを行うリソースがあるでしょう。
一方、3 人の学生で行う大学の課題プロジェクトでは、そのような大きなリソースを割くことができません。

プログラムにどれほどのテストやセキュリティが必要かにかかわらず、
常にエラーを発生させないような仕組みを作ることによって、
エラーを回避するという方法がソフトウェア開発では推奨されています。

この節では、
ソフトウェアのエラーを発見する方法や、
エラーに対処する方法、
また例外処理について紹介していきます。

まずは構文エラーと論理エラーについて学習していきましょう。


構文エラー
プログラミング言語の構文（syntax）は、私たちが使う自然言語の「文法」に非常に類似しています。
大文字で始まり、「?」、「!」、「.」のような句読点で終わる英語のように、
それぞれプログラミング言語は、読み手がコードを意味のある部分に分割し、理解できるようにルールが作られています。

各言語は、空白、特殊記号、構造に関する独自のルールがあるため、
コード内の命令を受け取り、最終的にはコンピュータのハードウェアによって意味のある解釈を行うことができます。
モダンな言語は、読みやすさ、書きやすさ、安全性を重視した構文を持っていますが、
静的型付け言語は、厳密かつ安全なので、複数人が参加する大規模なプロジェクトに適している傾向にあります。

静的型付け言語は、コードが文書化されている状態に近いため、
誤ったデータにアクセスしたり、データが不慮に混合することはありません。
一方、動的型付け言語は、作業が簡単で早く開発を行うことができるので、
安全性やコードの文書化はユーザーの責任になってしまいます。

では、以下のエディタで言語によるシンタックスの違いを見てみましょう。

'''Java
// Javaは、「//」をコメント行に使用します。
// また「{}」を関数定義のスコープを示すために使用します。
class Main{
    public static int calculateTotalCost(int subTotal, double taxRate){
        // 型と変数名を与えて、ローカル変数の宣言や初期化を行います。
        int totalCost = (int)((1 + taxRate) * subTotal);
        return totalCost;
    }

    // Javaはプログラムのエントリーポイントであるmainメソッドが必要です。
    public static void main(String[] args){

    }
}
'''

'''Python
# Pythonは、「#」をコメント行に使用します。
# また関数定義のスコープを示すためにインデントを使用します。

# キーワード「def」と「:」が必要です。
def calculateTotalCost(subTotal, taxRate):
    totalCost = (1 + taxRate) * subTotal
    return totalCost
'''

構文エラーは、コードがガイドラインに従っていない場合に発生します（記号、空白、順序の間違い等）。
この構文エラーによって、私たちはプログラム実行前にエラーの存在を知ることができます。
エラーが発生している限り、インタープリタはプログラムの実行を許可することはなく、
代わりにエラーに関する情報を提供してくれます。

プログラミング言語の構文規則は定義されており、比較的単純なので、
構文エラーを簡単に特定することができます。
ほとんどのコンパイラ、インタプリタ、IDE は構文エラーを自動検出してくれるので、
エラーがどの行にあるのか、どの構文規則に違反したのかを把握することができます。

構文エラーは決して悪いことではなく、エラーに対する最初の防御線として考えましょう。
それは、構文の厳密なルールと、構文のエラーを検出することによって、
記述したコードのロジックテストを行うことができるからです。
構文のルールには強制的に従う必要があるため、
コードは意味のある順序で実行され、機械語に適切に翻訳されるのです。


論理エラー
論理エラーとは、意図した通りの入出力関係にならないエラーのことを指します。
プログラミング言語のインタプリタやコンパイラ、IDE によって自動的に検出されず、
プログラムの実行が停止にならないため、論理エラーを特定するのは簡単ではありません。
プログラムがその内部に例え多くの論理エラーを含んでいたとしても、
エラーを示さないまま実行されることがあります。

ここで、もしエラーがあった際、コードのどの行にどのようなエラーが存在し、
それをどうやって特定すれば良いのか？と疑問に思う方もいるでしょう。

では、論理エラーの具体例を見てみます。

'''Java
import java.util.Arrays;

class Main{
    // 論理エラー1

    // 誤った税金計算
    public static double calculateTotalCost(int subTotal, double taxRate){
        double totalCost = (1 * taxRate) * subTotal;
        return totalCost;
    }

    // 論理エラー2

    // 大文字か小文字を考慮せず、昇順ソートしてしまう
    public static String[] sortStrings(String[] stringsToSort){
        String[] temp = stringsToSort;
        Arrays.sort(temp);
        return temp;
    }

    public static void main(String[] args){

        // 論理エラー1
        System.out.println(calculateTotalCost(100, .05));

        // 論理エラー2
        System.out.println(Arrays.toString(sortStrings(new String[]{"Tank", "Tiger","rabit","top","anger","billard"})));

    }
}

'''Python

# 論理エラー1

# 誤った税金計算
def calculateTotalCost(subTotal, taxRate):
    totalCost = (1 * taxRate) * subTotal
    return totalCost

print(calculateTotalCost(100, .05))

# 論理エラー2

# 大文字か小文字を考慮せず、昇順ソートしてしまう
def sortStrings(stringsToSort):
    temp = stringsToSort
    temp.sort()
    return temp

print(sortStrings(["Tank", "Tiger","rabit","top","anger","billard"]))

'''

このように、エラーを一切示さずに誤った結果を出すケースは数多く存在します。
論理エラーはケアレスミスが原因で発生することもありますが、
自分では気がつかないような思考のミスが原因で発生することもよくあります。

この場合、エラーはロジック自体の中にある可能性が高く、
これは自動的には検出されないので、
ミスを見つけ出して特定するのが非常に難しくなります。

構文エラーと違って、プログラミング言語はこのような論理エラーは検出しません。
間違った出力が出るケースを発見し、
開発したプログラムが正しいことを保証することがテストの目的となります。


まとめ
ソフトウェアプロジェクトのコード中のミスのことをエラーといい、
その中でも開発者が気づいたエラーのことをバグという。

動的型付け言語は作業が簡単で早く開発を行うことができるが、安全性は静的型付け言語と比べて低い。

適切な記号、間隔、順序、一般的な構造において、コードがフォーマットのガイドラインに従っていない場合に発生するエラーのことを構文エラーという。

構文エラーはプログラムの実行前に発生し、エラーに関する情報を提供してくれる。
そのためエラーの特定は容易である。

プログラムの実行が停止せず、期待通りの入出力関係にならないエラーのことを論理エラーという。

整数を入力すると、その数の 3 倍の値が出力される関数を作成した。
実際に 1 を入力してプログラムを実行させたところ、6 が出力された。
この場合のエラーを論理エラーという。


ソフトウェアテスト
開発者はコードやプログラムが使用される前に、
ソフトウェアに発生するエラーを防ぐのが理想的にはなりますが、
エラーが自動で捕まらない場合、
ソフトウェアテストを行うことで、
ソフトウェアのどこにエラーがあるのかを特定することができ、
その原因を絞り込むことができます。


ソフトウェアテストとは、
プログラムが意図した通りに動作するかどうかを発見するために
プログラムを実行する処理のことを指します。
コストが指数関数的に増大しないためにも、
テストはプログラムのリリース前や、
他のモジュールで使用される前に、
広範に行われることが推奨されています。


ソフトウェアの開発を行う際は、
コードのテストに 10-20% の時間を費やすことを念頭に置いておきましょう。
慎重にテストを行うことで、コスト、時間、労力を節約することができ、
エラーが他のプロジェクトに伝播するのを防ぐことができます。
エンドユーザーがプロダクトを使用するときが最終テストになります。


コストが多くかかりますが、重要なプロジェクトや重要なコンポーネントでは、
他のプロジェクトよりも多くのリソースを費やす必要があります。
例えば、糖尿病患者にインスリンを投与するポンプを制御するソフトウェアや、
飛行機のハードウェアのドライバなどを考えてみてください。
エンドユーザーの安全性は、エラーがないかどうかにかかっています。
これらのコンポーネントは、エンドユーザーにとっては動作が保証されているものであるため、
エンドユーザーに渡す前にソフトウェアテストでエラーをなくさなければなりません。

どのような場合でも、プログラマーはリソースが許す限りコードを徹底的にテストしますが、
できるだけテストが容易になるようにコードを書くのが一般的です。

ソフトウェアを 1 から開発していくように、
テストは
個々の行、数行のコード、関数、モジュール、クラス、ソフトウェア全体と
段階的なプロセスで行われます。
エラーが発見され、コードが修正、リファクタリングされると、
その変更が新たなエラーや望ましくない副作用が発生していないことを確認するためのテストが再度行われます。


テスト原則
条件を満たす特定の生徒を検索して、
名前を出力するアルゴリズムを開発する例を考えてみましょう。
学年、名前、年齢、身長、ID 等を基準にして、
生徒を検索することができますが、
要件（requirement）の内容にかかわらず、
実際に最初にテストを構築することができます。


では仮に、年齢、身長、ID を検索基準と仮定し、
最年少かつ最も背の高い学生を検索することにしてみましょう。
もし、同じ条件の学生が複数存在する場合は、若い ID を優先します。

テスト駆動開発（TDD）は、
まず要件を見て、テストケースに変換し、それに pass するためにコードを開発する
という考え方に基づいています。
要件とは、プログラムが持つべき機能と、それがどのように動作するかを指し、
今回の場合では、学生のリストをデータとして表現し、
最年少かつ最も背の高い学生の名前を取得することが要件となります。
テストケースは、入出力関係のセットであり、
それらが一致した場合は真を返し、そうでない場合は偽を返します。

RED -> GREEN -> リファクタリング

関数をコーディングする前に、TDD に従ってまずテストケースのセットを作成しましょう。
まずはリストからランダムな学生を返す関数でテストを行ってみます。

'''Python

import random

class Student:
    def __init__(self, studentId, grade, name, age, height):
        self.studentId = studentId
        self.grade = grade
        self.name = name
        self.age = age
        self.height = height

studentList1 = [
    Student(1000,9,"Matt Verdict", 14, 5.5),
    Student(1001,9,"Amy Lam", 14, 5.5),
    Student(1002,10,"Bryant Gonzales", 15, 5.9),
    Student(1003,9,"Kimberly York", 15, 5.3),
    Student(1004,11,"Christine Bryant", 15, 5.8),
    Student(1005,10,"Mike Allen", 16, 6.2),
]

studentList2 = [
    Student(1000,9,"Matt Verdict", 14, 5.5),
    Student(1001,9,"Amy Lam", 13, 5.5),
    Student(1002,10,"Bryant Gonzales", 15, 5.9),
    Student(1003,9,"Kimberly York", 15, 5.3),
    Student(1004,11,"Christine Bryant", 15, 5.8),
    Student(1005,10,"Mike Allen", 16, 6.2),
]

# ランダムな学生を返します。
def chooseStudent(studentList):
    return studentList[random.randint(0, len(studentList) - 1)]

# テストケース。Falseが出力された時は間違った出力になります。
print(chooseStudent(studentList1).studentId == 1000) # リスト1で最年少かつ最も身長が高い学生は、Matt Verdictです。(ID:1000)
print(chooseStudent(studentList2).studentId == 1001) # リスト2で最年少かつ最も身長が高い学生は、Amy Lamです。(ID:1001)

'''

TDD では、先に入出力関係をしっかり考えた後に、開発を行います。
開発後にテストケースを追加し、コードの拡張、修正を行うことで、
想定外のケースを短い開発サイクルでカバーすることもできます。
例えば、3 と 4 を入力して、1 を生成するコードで、2 を生成してしまった場合、
すぐにコードにエラーがあるとわかります。

さらに良いことは、一度テストケースを設定してしまえば、
その後はコードをチェックする必要がないということです。
テストケースの設定は、開発者にセーフティネットを与え、
プログラムをリファクタリングしたり拡張したりする際における信頼性を高めます。
コードの拡張によってロジックエラーが発生したり、副作用が発生したりした場合、
以前に構築したテストケースがそれをキャッチします。
これは、防御的なプログラミングの一形態になります。

しかしながら、意図した入出力の保証を得られるだけで、
プログラムにエラーがないかどうかを判断することはできません。
想定外の入力がプログラムにエラーを起こす可能性もありますし、
それが見つかるとバグとみなされます。

では、コードを拡張してテストシナリオを追加し、
関数を実装してみましょう。
すべてのテストケースが合格していることを確認してください。

'''Python

import random

class Student:
    def __init__(self, studentId, grade, name, age, height):
        self.studentId = studentId
        self.grade = grade
        self.name = name
        self.age = age
        self.height = height

studentList1 = [
    Student(1000,9,"Matt Verdict", 14, 5.5),
    Student(1001,9,"Amy Lam", 14, 5.5),
    Student(1002,10,"Bryant Gonzales", 15, 5.9),
    Student(1003,9,"Kimberly York", 15, 5.3),
    Student(1004,11,"Christine Bryant", 15, 5.8),
    Student(1005,10,"Mike Allen", 16, 6.2),
]

studentList2 = [
    Student(1000,9,"Matt Verdict", 14, 5.5),
    Student(1001,9,"Amy Lam", 13, 5.5),
    Student(1002,10,"Bryant Gonzales", 15, 5.9),
    Student(1003,9,"Kimberly York", 15, 5.3),
    Student(1004,11,"Christine Bryant", 15, 5.8),
    Student(1005,10,"Mike Allen", 16, 6.2),
]

# 学生のリストが与えられるので、最年少で最も身長の高い学生を返す、関数を作成してください。もし、複数該当する場合は若いIDを持つ学生を優先してください。
def chooseStudent(studentList):
    # 最年少かつ最も身長の高い学生を探す
    target = studentList[0]

    for i in studentList[1:]:
        if i.age < target.age and i.height > target.height:
            target = i

        elif i.age == target.age and i.height == target.height:
            if i.studentId < target.studentId:
                target = i

    return target

print(chooseStudent(studentList1).studentId == 1000)
print(chooseStudent(studentList2).studentId == 1001)
# テストケースを以下作成してください。

print(chooseStudent(studentList1))
print(chooseStudent(studentList2))

'''

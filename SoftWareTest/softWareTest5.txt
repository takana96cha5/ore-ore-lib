テストケースの選択
ソフトウェアのテストでは何をテストケースにするかによって、
ソフトウェアプロジェクトに費やす労力と時間が大きく左右します。
特定のテストケースやテストケースのカテゴリを見落としてしまうと、
無駄なテストを何度も繰り返すことになり、
それがソフトウェアの変更やテスト回数の増加につながってしまうことがあるからです。

特に大規模なチームや予算のあるプロジェクトでは、
ソフトウェアの入出力要件を早めに決定する必要があり、
それが要件や設計仕様の一部となっている場合が多くあります。
テストケースは、想定しうる入出力を可能な限りカバーしておく必要があり、
プログラミングのソースコードの内、テストされた割合であるカバレッジで管理します。

テストケースを選択する際に、以下の 3 つの知見を知っておくと良いでしょう。

ソフトウェアの用途とユーザーに関する知識
- 作り手の意図した用途での使用
- 作り手の意図しない用途での使用
- ソフトウェアを使うユーザーに関する特性

問題に関する知識
- 式、エッジケース、値の範囲
- 専門家への相談
- 例外的ケース

類似ソフトウェアに関する知識
- 類似のプロジェクトでエラーが発生した分野
- 経験則とテストケースの再利用

テストケースは、ソフトウェアが期待通りに動作することを保証し、
エラーがあればそれを明らかにする必要があります。
要件をカバーし、整合性をチェックするテストを含めることが推奨されますが、
ガイドラインに基づいたテストとパーティションに基づいたテストによって、
テストケースを選択することができます。

過去の経験に基づいて作成されたガイドラインによって一連のテストを実施することがあります。
これらのガイドラインには、
プログラマーがよく起こすエラーや類似のソフトウェア内でよく起こるエラーが含まれています。
では、例を見てみましょう。

- ユーザの入力を受ける関数は、入力データのデータ型と中身に特に注意し、無効な入力がすべて適切に処理されることをテストします。
- オブジェクトを引数に取る関数では、null が渡されたときに関数が適切に動作する必要があります。
- システムの状態が出力に影響を与える可能性がある場合に、同じ値を複数回テストします。
- リストや配列を取る関数では、要素が過剰に少ない場合と過剰に多い場合をテストします。
- 入力/出力に限界や範囲がある場合は、常に限界/範囲のテストを追加します。
- 同じ入力を複数回連続してテストします。
- プログラミング言語でデータ型がサポートする最大値と最小値を使用します。

パーティションに基づいたテストでは、すべての可能な入力を考慮し、
プログラムで同じように処理される入力値のグループやカテゴリを特定し、
各カテゴリが少なくとも一度はテストされるようにテストを選択します。
パーティションの特定後は、その境界線周辺にテストケースを作成します。
なぜなら、バグはこの境界線の端または境界に多く存在するからです。


実行時エラー
実行時エラー（runtime error）とは、プログラム実行時に発生し、
プログラム全体を即座にクラッシュさせるものを指します。
プログラム実行時とは、コードが実行されている間のことを意味し、
コードがコンパイルされた後、
あるいはコンパイラやインタプリタによってそれぞれ解釈された後のことになります。
これらのエラーは、
コードが実行される前に発生するので、
構文エラーではありません。

実行時に間違ったインデックスにアクセスしてしまう例を見てみましょう。

'''Python

def accessFault(l):
    # エラー。本来ならlen(l)であるはず。
    return l[len(l)]

accessFault([3,4,5,3,10,23])

'''

動的言語は、型チェックがなく、
データ型が混在した状態でのデータ操作が行われやすいため、
実行時エラーが頻繁に発生します。
よくある例として、
オブジェクト、文字列、整数等の異なるデータ型に対して、
+ 演算子を使用してしまうことです。
他にも、オブジェクト参照が null のメンバ変数に
アクセス演算子（object.member）を使用すると参照するものが何もなく、
実行時エラーが発生しまうことがあります。

その他の実行時エラーは、ユーザーとプログラムとのやりとりによっても発生します。
例えば、accessFault のシナリオで、ユーザーがインデックスを入力したり、
ハッシュマップでキーを入力できるという状況下で、
プログラムの入力範囲内の値を入力しなかった場合、
システムがクラッシュしてしまう可能性があります。

コード内でエラーが発生した場合、プログラミング言語は、
セキュリティ対策としてシステムを強制的に停止させてクラッシュさせます。
例として、中級「再帰」の節で学習した、
x の平方根を推定する再帰的な計算である squareRoot 関数を見てみましょう。

この関数は常に正の整数を返します。
負の数が渡された場合、負の数の平方根は虚数になりますが、
関数の出力が他の整数を入力として受けとる計算に使われるため、
この関数は -1、False、NaN、null を返すことはできません。
同様に関数が 0 を返す場合も正しくありません。
それは、0 の squareRoot だけが 0 を返すべきであり、
致命的な問題を引き起こすためです。

その場合、実行時エラーであるアサーションエラーが発生しますが、
独自のカスタムエラーを発生させることによって対処してみましょう。

'''
class SquareRootError(Exception):
    pass

# xの平方根を小数点6桁以下を丸めて返します。
def squareRoot(x):
    # xが0の時、0を返します。
    if x == 0: return 0

    # 負の数値に対してはエラーを吐きます。
    # Python多くのエラーは多くのエラーを返します。（NameError, AssertionError, EOFError, FloatingPointError, IndexError等）
    # ここでは、例外クラスを継承したSquareRootError(Exception)というクラスを作成して、独自のエラーを定義しています。継承についてはOOP講座を参照してください。
    # エラーを発生させるために、raiseキーワードを使用し、例外を定義するクラスで従います。
    if x < 0: raise SquareRootError

    def isSquareRootCloseEnough(a, b):
        return abs(a / b - b) < (b * 0.000001)

    def squareRootHelper(x, guess):
        if isSquareRootCloseEnough(x, guess):
            return round(guess,5)
        return squareRootHelper(x, (guess + x / guess) / 2)

    return squareRootHelper(x, 1)

if __name__ == '__main__':
    print(squareRoot(65))
    print(squareRoot(4))
    print(squareRoot(25))
    print(squareRoot(16))
    print(squareRoot(36))
    print(squareRoot(353))

print(squareRoot(-9))  # ERROR
'''


例外
処理がエラーを引き起こし、
開発者が実行時にエラーを対処することができる場合、
このエラーは例外（exception）と呼ばれます。
関数がエラーや例外を吐くことができる場合、
その関数にスローアブル（throwable）が含まれていると表現されます。

関数 -> スローアプル -> エラー or 例外


エラーの場合、開発者は実行時にその問題に対して何もできず、
プログラムがクラッシュしてしまいます。
これは致命的なエラー（fatal error）と呼ばれます。
一方、例外の場合は、実行時に問題を処理することができます。

例外を吐く関数の処理を考えてみましょう。
正常に動作し、何もエラーがなければ、
コードは通常通りに動作し続けます。
しかし、仮に例外が吐かれ、その例外を処理している場合、
例外をキャッチしていると表現されます。
この処理は try-catch 文と呼ばれる制御フローによって行われます。

スローアブルを含む関数の呼び出しが try-catch 文でラップされていない場合、
例外処理をしないという選択を取ったとみなされ、
実行された関数が例外を吐くと自動的に致命的なエラーになります。
この制御フローの仕組みによって、
開発者が例外を上手く処理したり、
例外をエラーとして処理することができます。

例外をキャッチしたら例外処理を走らせます。

例えば、スローアブルな関数 squareRoot は、
負の整数を入力として受け取った時にエラーを吐きます。
仮に、他の開発者がこの関数を使用したい際には、
その開発者にどのようにエラーに対処するか委ねることができます。
例外として処理するか、
致命的なエラーとして処理するかはこの開発者によることになります。

では、関数の呼び出し squareRoot(-9) を try-catch 文で囲み、
例外をキャッチすることでコードを拡張してみましょう。
今回、squareRoot が全く重要な役割を持っておらず、
存在しなくても特に何も発生しないと仮定し、
致命的なエラーを発生させずに例外として処理します。

'''
class SquareRootError(Exception):
    pass

def squareRoot(x):
    if x == 0: return 0

    # 例外をインスタンスオブジェクトとしてメッセージと共に渡すこともできます。
    # これはキャッチされたときに使われ、具体的に何が起こったのかについてより多くの情報を提供する必要があります。
    if x < 0: raise SquareRootError(f"Square root error for the squareRoot function, line 17!!! This function cannot contain a negative integer and {x} was passed in!")

    def isSquareRootCloseEnough(a, b):
        return abs(a / b - b) < (b * 0.000001)

    def squareRootHelper(x, guess):
        if isSquareRootCloseEnough(x, guess):
            return round(guess,5)
        return squareRootHelper(x, (guess + x / guess) / 2)

    return squareRootHelper(x, 1)

if __name == '__main__':
    print(squareRoot(65))
    print(squareRoot(4))
    print(squareRoot(25))
    print(squareRoot(16))
    print(squareRoot(36))
    print(squareRoot(353))

    # try-catch文の周りで、例外エラーを返す可能性があるステートメントをラップします。
    # Pythonではcatchの代わりに「except」というキーワードが使われます。except {ExceptionName}.

    # tryの中で以下の文を実行してみてください。
    try:
        print(squareRoot(-9))  # ERROR

    # tryに失敗した場合は例外をキャッチします。
    # キャッチしようとしているのはSquareRootErrorです。制御フローはこのインスタンスオブジェクトを作成して、errに割り当てます。
    except SquareRootError as err:
        # エラーは発生しません。試したステートメントが重要ではないことがわかります。
        # 致命的なエラーを起こさずに、起きたことをログ情報にして、プログラムを実行し続けます。
        print("Error occured and it looks like it was a SquareRootError..." + str(err))

    print(squareRoot(90))
    print(squareRoot(81))
    print(squareRoot(54442))

    try:
        print(squareRoot(-456))  # ERROR
    # また、SquareRootErrorをキャッチして他のすべてのエラーを致命的なエラーにするのではなく、すべての例外を意味する汎用的な例外をキャッチすることもあります。
    except Exception as err:
        print("Error occured and it looks like it was an... I am not sure, this is a generic exception with the message:" + str(err))
'''

まとめ
パーティションに基づいたテストでは、パーティションの境界線周辺にテストケースを作成するのが通例である。

プログラム実行時に発生し、プログラム全体を即座にクラッシュさせるエラーのことを実行時エラーという。

Python の処理で、実行時エラーに当たらない例として "word" + "3" があげられる

開発者が実行時に対処できるエラーのことを例外という。
